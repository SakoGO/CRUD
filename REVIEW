Тесты

Сервис аворизации для авторов
    У каждого автора доступ только к своим книгам


Кэш
    Для GetBookID составлять кэш
    Для Update и Delete убивать кэш

    1. Модификация сервиса для работы с JWT
    Вместо того, чтобы возвращать пользователя в сервисе, мы будем генерировать и возвращать JWT токен.

    internal/service/user_service.go
    Добавим код для генерации JWT токенов:

    go
    Копировать код
    package service

    import (
    	"CRUDVk/internal/models"
    	"CRUDVk/internal/repository"
    	"fmt"
    	"golang.org/x/crypto/bcrypt"
    	"github.com/golang-jwt/jwt/v4"
    	"time"
    )

    type UserService interface {
    	Register(username, email, password string) (*models.User, error)
    	Login(username, password string) (string, error)  // Возвращаем токен вместо пользователя
    }

    type userService struct {
    	repo      repository.UserRepository
    	secretKey string // Секретный ключ для подписи JWT
    }

    func NewUserService(repo repository.UserRepository, secretKey string) UserService {
    	return &userService{repo: repo, secretKey: secretKey}
    }

    func (s *userService) Register(username, email, password string) (*models.User, error) {
    	existingUser, _ := s.repo.FindByUsername(username)
    	if existingUser != nil {
    		return nil, fmt.Errorf("пользователь с таким именем уже существует")
    	}

    	existingEmail, _ := s.repo.FindByEmail(email)
    	if existingEmail != nil {
    		return nil, fmt.Errorf("пользователь с таким email уже существует")
    	}

    	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    	if err != nil {
    		return nil, err
    	}

    	user := &models.User{
    		Username: username,
    		Email:    email,
    		Password: string(hashedPassword),
    	}

    	if err := s.repo.CreateUser(user); err != nil {
    		return nil, err
    	}

    	return user, nil
    }

    func (s *userService) Login(username, password string) (string, error) {
    	user, err := s.repo.FindByUsername(username)
    	if err != nil {
    		return "", fmt.Errorf("пользователь не найден")
    	}

    	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
    	if err != nil {
    		return "", fmt.Errorf("неверный пароль")
    	}

    	// Генерация JWT токена
    	token, err := s.generateJWTToken(user.ID)
    	if err != nil {
    		return "", err
    	}

    	return token, nil
    }

    // Генерация JWT токена
    func (s *userService) generateJWTToken(userID uint) (string, error) {
    	claims := jwt.MapClaims{
    		"sub": userID,           // ID пользователя
    		"exp": time.Now().Add(time.Hour * 24).Unix(), // Истекает через 24 часа
    	}

    	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

    	// Подписываем токен с использованием секретного ключа
    	tokenString, err := token.SignedString([]byte(s.secretKey))
    	if err != nil {
    		return "", fmt.Errorf("не удалось создать токен: %v", err)
    	}

    	return tokenString, nil
    }
    2. Хендлеры для работы с JWT
    Теперь хендлеры должны использовать JWT для логина и защиты маршрутов.

    internal/transport/handler/user_handler.go
    Изменим хендлеры так, чтобы они возвращали JWT токен при успешной авторизации:

    go
    Копировать код
    package handler

    import (
    	"CRUDVk/internal/service"
    	"encoding/json"
    	"net/http"
    )

    // Структура для хендлера
    type UserHandler struct {
    	UserService service.UserService
    }

    // Конструктор хендлера
    func NewUserHandler(userService service.UserService) *UserHandler {
    	return &UserHandler{UserService: userService}
    }

    // Хендлер для регистрации
    func (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {
    	var user struct {
    		Username string `json:"username"`
    		Email    string `json:"email"`
    		Password string `json:"password"`
    	}

    	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
    		http.Error(w, "Неверный формат данных", http.StatusBadRequest)
    		return
    	}

    	newUser, err := h.UserService.Register(user.Username, user.Email, user.Password)
    	if err != nil {
    		http.Error(w, err.Error(), http.StatusConflict)
    		return
    	}

    	// Ответ успешной регистрации
    	w.WriteHeader(http.StatusCreated)
    	json.NewEncoder(w).Encode(newUser)
    }

    // Хендлер для логина (возвращаем токен)
    func (h *UserHandler) Login(w http.ResponseWriter, r *http.Request) {
    	var user struct {
    		Username string `json:"username"`
    		Password string `json:"password"`
    	}

    	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
    		http.Error(w, "Неверный формат данных", http.StatusBadRequest)
    		return
    	}

    	token, err := h.UserService.Login(user.Username, user.Password)
    	if err != nil {
    		http.Error(w, err.Error(), http.StatusUnauthorized)
    		return
    	}

    	// Возвращаем JWT токен
    	w.WriteHeader(http.StatusOK)
    	json.NewEncoder(w).Encode(map[string]string{"token": token})
    }
    3. Защита маршрутов с помощью JWT
    Для защищенных маршрутов можно использовать миддлвар, который будет проверять токен:

    internal/transport/handler/middleware.go
    go
    Копировать код
    package handler

    import (
    	"CRUDVk/internal/service"
    	"fmt"
    	"net/http"
    	"strings"
    	"github.com/golang-jwt/jwt/v4"
    )

    // Миддлвар для проверки JWT токена
    func (h *UserHandler) Authenticate(next http.HandlerFunc) http.HandlerFunc {
    	return func(w http.ResponseWriter, r *http.Request) {
    		authHeader := r.Header.Get("Authorization")
    		if authHeader == "" {
    			http.Error(w, "Отсутствует токен авторизации", http.StatusUnauthorized)
    			return
    		}

    		tokenStr := strings.TrimPrefix(authHeader, "Bearer ")

    		// Проверка валидности токена
    		claims := jwt.MapClaims{}
    		_, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
    			return []byte(h.UserService.SecretKey), nil
    		})

    		if err != nil {
    			http.Error(w, "Не удалось проверить токен", http.StatusUnauthorized)
    			return
    		}

    		// Разрешаем доступ к защищенному ресурсу
    		next(w, r)
    	}
    }
    4. Модификация маршрутов для защиты
    Добавим новый маршрут, защищенный через JWT:

    internal/transport/handler/routes.go
    go
    Копировать код
    package handler

    import (
    	"net/http"
    )

    // Инициализация маршрутов
    func InitRoutes(userHandler *UserHandler) *http.ServeMux {
    	mux := http.NewServeMux()

    	// Регистрация и авторизация
    	mux.HandleFunc("/register", userHandler.Register)
    	mux.HandleFunc("/login", userHandler.Login)

    	// Пример защищенного маршрута
    	mux.HandleFunc("/protected", userHandler.Authenticate(userHandler.Protected))

    	return mux
    }

    // Пример защищенного маршрута
    func (h *UserHandler) Protected(w http.ResponseWriter, r *http.Request) {
    	// Возвращаем информацию о защищенном ресурсе
    	w.Write([]byte("Вы получили доступ к защищенному ресурсу!"))
    }
    Заключение
    Теперь ваш проект использует JWT токены для авторизации пользователей. При логине пользователь получает токен, который нужно отправить в заголовке Authorization для доступа к защищенным маршрутам.